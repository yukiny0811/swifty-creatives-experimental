// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8.1 (swiftlang-5.8.0.124.5 clang-1403.0.22.11.100)
// swift-module-flags: -target arm64-apple-macos13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name iGeometry
import Darwin
import Swift
import _Concurrency
import _StringProcessing
extension Swift.Int {
  public static let empty: Swift.Int
}
public struct PathList<T> {
  public struct Item {
    public let index: Swift.Int
    public let value: T
  }
  public var count: Swift.Int {
    get
  }
  public var first: iGeometry.PathList<T>.Item {
    get
  }
  public var sequence: [T] {
    get
  }
  public var indices: [Swift.Int] {
    get
  }
  public subscript(index: Swift.Int) -> T {
    get
  }
  public init(size: Swift.Int, empty: T)
  public init(array: [T], empty: T)
  public func next(_ index: Swift.Int) -> iGeometry.PathList<T>.Item
  public func prev(_ index: Swift.Int) -> iGeometry.PathList<T>.Item
  public func contains(_ index: Swift.Int) -> Swift.Bool
  public func contains(where predicate: (T) -> Swift.Bool) -> Swift.Bool
  public func contains(where predicate: (Swift.Int, T) -> (Swift.Bool)) -> Swift.Bool
  public mutating func remove(_ index: Swift.Int)
  public mutating func removeAll()
  public func firstIndex(where predicate: (T) -> (Swift.Bool)) -> Swift.Int
  public func firstIndex(where predicate: (Swift.Int, T) -> (Swift.Bool)) -> Swift.Int
  public func first(where predicate: (T) -> (Swift.Bool)) -> T?
  public func forEachIndex(_ body: (Swift.Int) -> ())
}
public struct RingSet {
  public var isEmpty: Swift.Bool {
    get
  }
  public var first: Swift.Int {
    get
  }
  public var sequence: [Swift.Int] {
    get
  }
  public init(size: Swift.Int)
  public func next(_ element: Swift.Int) -> Swift.Int
  public func prev(_ element: Swift.Int) -> Swift.Int
  public func contains(_ element: Swift.Int) -> Swift.Bool
  public mutating func remove(_ element: Swift.Int)
  public func forEach(_ body: (Swift.Int) -> ())
  public mutating func removeAll()
}
extension iGeometry.PlainShape {
  public enum Validation {
    public struct Edge {
      public let a: Swift.Int
      public let b: Swift.Int
    }
    case valid
    case hasSamePoints(Swift.Int, Swift.Int)
    case hullIsNotClockWise
    case holeIsNotCounterClockWise(Swift.Int)
    case hullIsSelfIntersecting(iGeometry.PlainShape.Validation.Edge, iGeometry.PlainShape.Validation.Edge)
    case holeIsSelfIntersecting(iGeometry.PlainShape.Validation.Edge, iGeometry.PlainShape.Validation.Edge)
    case hullIsIntersectingHole(iGeometry.PlainShape.Validation.Edge, iGeometry.PlainShape.Validation.Edge)
    case holeIsIntersectingHole(iGeometry.PlainShape.Validation.Edge, iGeometry.PlainShape.Validation.Edge)
  }
  public func isClockWise(index: Swift.Int) -> Swift.Bool
  public func validate() -> iGeometry.PlainShape.Validation
}
public struct Circle {
  public let center: iGeometry.Point
  public let radius: Swift.Float
  public init(center: iGeometry.Point, radius: Swift.Float)
}
extension iGeometry.IntPoint {
  public static func + (left: iGeometry.IntPoint, right: iGeometry.IntPoint) -> iGeometry.IntPoint
  public static func - (left: iGeometry.IntPoint, right: iGeometry.IntPoint) -> iGeometry.IntPoint
  public func scalarMultiply(point: iGeometry.IntPoint) -> Swift.Int64
  public func crossProduct(point: iGeometry.IntPoint) -> Swift.Int64
  public func normal(iGeom: iGeometry.IntGeom) -> iGeometry.IntPoint
  public func sqrDistance(point: iGeometry.IntPoint) -> Swift.Int64
  public static func isSameLine(a: iGeometry.IntPoint, b: iGeometry.IntPoint, c: iGeometry.IntPoint) -> Swift.Bool
}
public struct Rect {
  public static let empty: iGeometry.Rect
  public var minX: Swift.Int64
  public var minY: Swift.Int64
  public var maxX: Swift.Int64
  public var maxY: Swift.Int64
  public init(minX: Swift.Int64, minY: Swift.Int64, maxX: Swift.Int64, maxY: Swift.Int64)
  public init(a: iGeometry.IntPoint, b: iGeometry.IntPoint)
  public mutating func assimilate(p: iGeometry.IntPoint)
  public func isNotIntersecting(a: iGeometry.IntPoint, b: iGeometry.IntPoint) -> Swift.Bool
  public func isIntersecting(rect: iGeometry.Rect) -> Swift.Bool
  public func isInside(rect: iGeometry.Rect) -> Swift.Bool
  public func isContain(_ point: iGeometry.IntPoint) -> Swift.Bool
}
public struct Triangle {
  public let a: iGeometry.Point
  public let b: iGeometry.Point
  public let c: iGeometry.Point
  public init(a: iGeometry.Point, b: iGeometry.Point, c: iGeometry.Point)
  public var area: Swift.Float {
    get
  }
  public var circumscribed小ircle: iGeometry.Circle {
    get
  }
  public var inscribed小ircle: iGeometry.Circle {
    get
  }
  public static func circumscribed小ircle(a: iGeometry.Point, b: iGeometry.Point, c: iGeometry.Point) -> iGeometry.Circle
  public static func inscribed小ircle(a: iGeometry.Point, b: iGeometry.Point, c: iGeometry.Point) -> iGeometry.Circle
}
public struct DBPoint {
  public static let zero: iGeometry.DBPoint
  public let x: Swift.Double
  public let y: Swift.Double
  public init(x: Swift.Double, y: Swift.Double)
  public init(iPoint: iGeometry.IntPoint)
  public func sqrDistance(point: iGeometry.DBPoint) -> Swift.Double
  public var normal: iGeometry.DBPoint {
    get
  }
  public func dotProduct(_ vector: iGeometry.DBPoint) -> Swift.Double
  public func crossProduct(_ vector: iGeometry.DBPoint) -> Swift.Double
  public static func == (lhs: iGeometry.DBPoint, rhs: iGeometry.DBPoint) -> Swift.Bool
}
public struct IntGeom {
  public static let defGeom: iGeometry.IntGeom
  public static let maxBits: Swift.Int
  public let scale: Swift.Float
  public let invertScale: Swift.Float
  public let sqrInvertScale: Swift.Float
  public init(scale: Swift.Float = 10000)
  public func int(float: Swift.Float) -> Swift.Int64
  public func sqrInt(float: Swift.Float) -> Swift.Int64
  public func int(point: iGeometry.Point) -> iGeometry.IntPoint
  public func int(points: [iGeometry.Point]) -> [iGeometry.IntPoint]
  public func int(paths: [[iGeometry.Point]]) -> [[iGeometry.IntPoint]]
  public func float(int: Swift.Int64) -> Swift.Float
  public func sqrFloat(int: Swift.Int64) -> Swift.Float
  public func float(point: iGeometry.IntPoint) -> iGeometry.Point
  public func float(points: [iGeometry.IntPoint]) -> [iGeometry.Point]
  public func float(paths: [[iGeometry.IntPoint]]) -> [[iGeometry.Point]]
}
public struct IntPoint {
  public static let zero: iGeometry.IntPoint
  public static let empty: iGeometry.IntPoint
  public let x: Swift.Int64
  public let y: Swift.Int64
  public var bitPack: Swift.Int64 {
    get
  }
  public init(x: Swift.Int64, y: Swift.Int64)
}
extension iGeometry.IntPoint : Swift.Equatable {
  public static func == (lhs: iGeometry.IntPoint, rhs: iGeometry.IntPoint) -> Swift.Bool
}
public struct Point : Swift.Equatable {
  public static let zero: iGeometry.Point
  public let x: Swift.Float
  public let y: Swift.Float
  public init(x: Swift.Float, y: Swift.Float)
  public func sqrDistance(point: iGeometry.Point) -> Swift.Float
  public var normal: iGeometry.Point {
    get
  }
  public func dotProduct(_ vector: iGeometry.Point) -> Swift.Float
  public func crossProduct(_ vector: iGeometry.Point) -> Swift.Float
  public static func == (lhs: iGeometry.Point, rhs: iGeometry.Point) -> Swift.Bool
}
extension Swift.Array where Element == iGeometry.IntPoint {
  public var area: Swift.Int64 {
    get
  }
  public mutating func invert()
}
public struct IntShape {
  public static let empty: iGeometry.IntShape
  public var hull: [iGeometry.IntPoint]
  public var holes: [[iGeometry.IntPoint]]
  public init(shape: iGeometry.Shape, iGeom: iGeometry.IntGeom = .defGeom)
  public init(plainShape: iGeometry.PlainShape)
  public init(hull: [iGeometry.IntPoint], holes: [[iGeometry.IntPoint]])
}
extension iGeometry.PlainShape {
  public init(precision: Swift.Float = 0.0001, points: [iGeometry.Point], hull: Swift.ArraySlice<iGeometry.Point>, holes: [Swift.ArraySlice<iGeometry.Point>]? = nil)
  public init(iGeom: iGeometry.IntGeom, points: [iGeometry.Point], hull: Swift.ArraySlice<iGeometry.Point>, holes: [Swift.ArraySlice<iGeometry.Point>]? = nil)
  public init(precision: Swift.Float = 0.0001, hull: [iGeometry.Point], holes: [[iGeometry.Point]]? = nil)
  public init(iGeom: iGeometry.IntGeom, hull: [iGeometry.Point], holes: [[iGeometry.Point]]? = nil)
}
public struct PlainShape : Swift.Equatable {
  public struct Layout : Swift.Equatable {
    public let begin: Swift.Int
    public let length: Swift.Int
    public var end: Swift.Int {
      get
    }
    public let isClockWise: Swift.Bool
    public var isHole: Swift.Bool {
      get
    }
    public init(begin: Swift.Int, length: Swift.Int, isClockWise: Swift.Bool)
    public static func == (a: iGeometry.PlainShape.Layout, b: iGeometry.PlainShape.Layout) -> Swift.Bool
  }
  public static let empty: iGeometry.PlainShape
  public var points: [iGeometry.IntPoint]
  public var layouts: [iGeometry.PlainShape.Layout]
  public init(pointsCapacity: Swift.Int, layoutsCapacity: Swift.Int)
  public init(points: [iGeometry.IntPoint], layouts: [iGeometry.PlainShape.Layout])
  public init(points: [iGeometry.IntPoint])
  public init(iShape: iGeometry.IntShape)
  public func get(index: Swift.Int) -> [iGeometry.IntPoint]
  public func get(layout: iGeometry.PlainShape.Layout) -> [iGeometry.IntPoint]
  public mutating func add(hole: [iGeometry.IntPoint])
  public mutating func add(path: [iGeometry.IntPoint], isClockWise: Swift.Bool)
  public mutating func remove(index: Swift.Int)
  public mutating func replace(index: Swift.Int, path: [iGeometry.IntPoint])
  public static func == (a: iGeometry.PlainShape, b: iGeometry.PlainShape) -> Swift.Bool
}
public struct PlainShapeList {
  public static let empty: iGeometry.PlainShapeList
  public struct Segment : Swift.Equatable {
    public let begin: Swift.Int
    public let length: Swift.Int
    public var end: Swift.Int {
      get
    }
    public init(begin: Swift.Int, length: Swift.Int)
    public static func == (a: iGeometry.PlainShapeList.Segment, b: iGeometry.PlainShapeList.Segment) -> Swift.Bool
  }
  public var points: [iGeometry.IntPoint] {
    get
  }
  public var layouts: [iGeometry.PlainShape.Layout] {
    get
  }
  public var segments: [iGeometry.PlainShapeList.Segment] {
    get
  }
  public init(minimumPointsCapacity: Swift.Int, minimumLayoutsCapacity: Swift.Int, minimumSegmentsCapacity: Swift.Int)
  public init(points: [iGeometry.IntPoint], layouts: [iGeometry.PlainShape.Layout], segments: [iGeometry.PlainShapeList.Segment])
  public init(plainShape: iGeometry.PlainShape)
  public func get(index: Swift.Int) -> iGeometry.PlainShape
  public mutating func add(plainShape: iGeometry.PlainShape)
  public mutating func append(list: iGeometry.PlainShapeList)
}
public struct Shape {
  public static let empty: iGeometry.Shape
  public var hull: [iGeometry.Point]
  public var holes: [[iGeometry.Point]]
  public init(shape: iGeometry.IntShape, iGeom: iGeometry.IntGeom = .defGeom)
  public init(hull: [iGeometry.Point], holes: [[iGeometry.Point]])
}
public typealias Index = Swift.Int
public let null: Swift.Int
public struct Vertex {
  public enum Nature {
    case origin
    case extraPath
    case extraInner
    case extraTessellated
    public var isPath: Swift.Bool {
      get
    }
    public static func == (a: iGeometry.Vertex.Nature, b: iGeometry.Vertex.Nature) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let empty: iGeometry.Vertex
  public let index: iGeometry.Index
  public let point: iGeometry.IntPoint
  public let nature: iGeometry.Vertex.Nature
  public init(index: iGeometry.Index, nature: iGeometry.Vertex.Nature, point: iGeometry.IntPoint)
}
extension iGeometry.Simplificator {
  public enum Direction {
    case colinear
    case abDot
    case none
    public static func == (a: iGeometry.Simplificator.Direction, b: iGeometry.Simplificator.Direction) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public struct Simplificator {
  public static let plain: iGeometry.Simplificator
  public struct Result {
    public let isModified: Swift.Bool
    public let points: [iGeometry.IntPoint]
    public init(isModified: Swift.Bool, points: [iGeometry.IntPoint])
  }
  public enum Strategy {
    case no
    case linear
    public static func == (a: iGeometry.Simplificator.Strategy, b: iGeometry.Simplificator.Strategy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let strategy: iGeometry.Simplificator.Strategy
  public let minDistance: Swift.Int64
  public let minArea: Swift.Int64
  public let maxCos: Swift.Float
  public init(strategy: iGeometry.Simplificator.Strategy, minDistance: Swift.Int64, minArea: Swift.Int64, minAngle grad: Swift.Float)
  public init(strategy: iGeometry.Simplificator.Strategy = .linear, minDistance: Swift.Int64 = 10, minAngle grad: Swift.Float = 0.1)
  public func simplify(points: [iGeometry.IntPoint], isClockWise: Swift.Bool) -> iGeometry.Simplificator.Result
}
extension iGeometry.Vertex.Nature : Swift.Equatable {}
extension iGeometry.Vertex.Nature : Swift.Hashable {}
extension iGeometry.Simplificator.Direction : Swift.Equatable {}
extension iGeometry.Simplificator.Direction : Swift.Hashable {}
extension iGeometry.Simplificator.Strategy : Swift.Equatable {}
extension iGeometry.Simplificator.Strategy : Swift.Hashable {}
